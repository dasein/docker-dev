#!/usr/bin/env python

"""Bring up docker development environment

This is meant to be a wrapper script around docker-machine in order to
facilitate some of the boilerplate associated around bringing up a docker
development environmnet.

Run docker-machine --help to see how you can further manage your docker
development environment once it comes up.

Right now docker-dev just tries to do the following things.

- Set some sane CPU_COUNT and MEMORY_SIZE settings for your docker-machine
- Guess your VM preference based off of what you have installed
- Allow your machine name to be resolvable through multicast DNS (e.g.
  MACHINE_NAME.local)

Example:
    docker-dev create hiworld

    or

    MACHINE_NAME=foo docker-dev create && ping -c1 foo.local

Note that all args can be set by the equivalently named environment
variable. (e.g. MACHINE_DRIVER)
"""
import argparse
import logging
import os
import subprocess
import sys


class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter,
                      argparse.RawDescriptionHelpFormatter):
    """Argparse formatter to display __doc__ string correctly"""
    pass


DEFAULT_MACHINE_ENV = {
    'FUSION_CPU_COUNT': '4',
    'VIRTUALBOX_CPU_COUNT': '4',
    'FUSION_MEMORY_SIZE': '1024',
    'VIRTUALBOX_MEMORY_SIZE': '1024',
}

PARSER = argparse.ArgumentParser(description=__doc__,
                                 formatter_class=CustomFormatter)
PARSER.add_argument('-v', '--verbose', dest='verbose',
                    action='store_true',
                    help='Be more verbose about what docker-dev is doing.')
PARSER.add_argument('-b', '--branch', dest='branch',
                    default=os.getenv('MACHINE_DRIVER', 'master'),
                    help='What git branch/tag to track for updates')
PARSER.add_argument('-d', '--driver', dest='MACHINE_DRIVER',
                    default=os.getenv('MACHINE_DRIVER'),
                    help='What driver to use to bring up docker-dev. '
                    'If not specified, tries to guess. '
                    '[ vmwarefusion >> virtualbox ]')

log = logging.getLogger('docker-dev')


def cmd(cmd, output=False, cwd=None):
    """Run shell cmd and return exit status or output"""

    log.debug('Running cmd: %s', cmd)

    if output:
        run = subprocess.check_output
    else:
        run = subprocess.check_call

    try:
        out = run(cmd, shell=True, cwd=cwd)
    except subprocess.CalledProcessError, e:
        sys.exit(1)

    return out


def create(args):
    """Create and start a docker-machine"""

    drivers = ['vmwarefusion', 'virtualbox']
    name = args.MACHINE_NAME

    if args.MACHINE_DRIVER in drivers:
        driver = args.MACHINE_DRIVER
    elif os.path.isdir('/Applications/VMware Fusion.app/'):
        driver = 'vmwarefusion'
    else:
        driver = 'virtualbox'

    cmd('docker-machine create -d %(driver)s %(name)s || :' % locals())
    start(args)


def start(args):
    """Start the docker-machine"""
    name = args.MACHINE_NAME

    cmd('docker-machine start %s || :' % name)
    cmd('docker-machine scp /usr/local/docker-dev/machine/bootsync.sh %s:/tmp/bootsync.sh' % name)
    cmd('docker-machine ssh %s sudo mv /tmp/bootsync.sh /var/lib/boot2docker/bootsync.sh' % name)
    cmd('docker-machine ssh %s /var/lib/boot2docker/bootsync.sh' % name)
    log.info('*' * 50)
    cmd('docker-machine env %s' % name)
    log.info('*' * 50)
    log.info('Docker machine available at %s.local' % name)
    log.info('*' * 50)


def stop(args):
    """Stops the docker-machine"""
    cmd('docker-machine stop %s' % args.MACHINE_NAME)


def update(args):
    """Updates docker-dev to the latest version"""
    cwd = '/usr/local/docker-dev'
    dirname = os.path.dirname(os.path.realpath(__file__))

    if dirname == '/usr/local/docker-dev/bin':
        cmd('git fetch -q https://github.com/dasein/docker-dev.git %s' % args.branch, cwd=cwd)
        cmd('git reset --hard FETCH_HEAD', cwd=cwd)
    else:
        log.info('docker-dev is not installed in %s (Skipping git update)', cwd)

    playbook = os.path.join(dirname, '../ansible/docker.yml')
    cmd('ansible-playbook %s -i 127.0.0.1,' % playbook)


def upgrade(args):
    """Upgrades docker-machine to latest version of boot2docker"""
    cmd('docker-machine upgrade %s' % args.MACHINE_NAME)


def rm(args):
    """Removes the docker-machine"""
    cmd('docker-machine rm %s' % args.MACHINE_NAME)


def ls(args):
    """Lists the docker-machine(s)"""
    cmd('docker-machine ls')


def main():
    """Setup and invoke docker-dev environment"""
    logging.basicConfig(stream=sys.stderr, format='%(message)s')

    env = os.environ.keys()
    os.environ.update({k:v for k,v in DEFAULT_MACHINE_ENV.iteritems() if k not in env})

    bare_commands = [ update, ls ]
    name_commands = [create, start, stop, rm, upgrade]

    subparsers = PARSER.add_subparsers()
    for command in bare_commands + name_commands:
        s = subparsers.add_parser(command.__name__, help=command.__doc__)
        if command in name_commands:
            s.add_argument('MACHINE_NAME', nargs='?', default=os.getenv('MACHINE_NAME'))
        s.set_defaults(func=command)

    args = PARSER.parse_args()

    if args.verbose:
        log.setLevel(logging.DEBUG)
    else:
        log.setLevel(logging.INFO)

    if 'MACHINE_NAME' in args and not args.MACHINE_NAME:
        log.info('MACHINE_NAME not set, using "dev" as machine name')
        args.MACHINE_NAME = 'dev'

    args.func(args)

if __name__ == '__main__':
    main()
