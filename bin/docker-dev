#!/usr/bin/env python

"""Bring up docker development environment

This is meant to be a wrapper script around docker-machine in order to
facilitate some of the boilerplate associated around bringing up a docker
development environmnet.

Run docker-machine --help to see how you can further manage your docker
development environment once it comes up.

Right now docker-dev just tries to do the following things.

- Set some sane CPU_COUNT and MEMORY_SIZE settings for your docker-machine
- Guess your VM preference based off of what you have installed
- Allow your machine name to be resolvable through multicast DNS (e.g.
  MACHINE_NAME.local)

Example:
    docker-dev create hiworld

    or

    MACHINE_NAME=foo docker-dev create && ping -c1 foo.local

Note that all args can be set by the equivalently named environment
variable. (e.g. MACHINE_DRIVER)
"""
import argparse
import logging
import os
import subprocess
import sys


class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter,
                      argparse.RawDescriptionHelpFormatter):
    """Argparse formatter to display __doc__ string correctly"""
    pass


DEFAULT_MACHINE_ENV = {
    'FUSION_CPU_COUNT': '4',
    'VIRTUALBOX_CPU_COUNT': '4',
    'FUSION_MEMORY_SIZE': '4000',
    'VIRTUALBOX_MEMORY_SIZE': '4000',
}

CWD = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))

CLUSTER_OPTIONS = [ None, 'kubernetes', 'swarm' ]

PARSER = argparse.ArgumentParser(description=__doc__,
                                 formatter_class=CustomFormatter)
PARSER.add_argument('-v', '--verbose', dest='verbose',
                    action='store_true',
                    help='Be more verbose about what docker-dev is doing.')
PARSER.add_argument('-b', '--branch', dest='GIT_BRANCH',
                    default=os.getenv('GIT_BRANCH', 'master'),
                    help='What git branch/tag to track for updates')
PARSER.add_argument('-c', '--cluster', dest='DOCKER_CLUSTER',
                    default=os.getenv('DOCKER_CLUSTER', None), choices=CLUSTER_OPTIONS,
                    help='What docker orchestration to use for clustering DOCKER_CLUSTER')
PARSER.add_argument('-t', '--token', dest='SWARM_TOKEN',
                    default=os.getenv('SWARM_TOKEN', 'ddb2cdf717a829bd3d583986522f3809'),
                    help='Token to use for swarm cluster')
PARSER.add_argument('-d', '--driver', dest='MACHINE_DRIVER',
                    default=os.getenv('MACHINE_DRIVER'),
                    help='VM driver to use for docker daemon'
                    'If not specified, tries to guess. '
                    '[ vmwarefusion >> virtualbox ]')

log = logging.getLogger('docker-dev')


def cmd(cmd, output=False, cwd=CWD):
    """Run shell cmd and return exit status or output"""

    log.debug('Running cmd: %s', cmd)
    if output:
        run = subprocess.check_output
    else:
        run = subprocess.check_call

    try:
        out = run(cmd, shell=True, cwd=cwd)
    except subprocess.CalledProcessError, e:
        sys.exit(1)

    return out


def create(args):
    """Create and start a docker-machine"""

    drivers = ['vmwarefusion', 'virtualbox']
    name = args.MACHINE_NAME

    if args.MACHINE_DRIVER in drivers:
        driver = args.MACHINE_DRIVER
    elif os.path.isdir('/Applications/VMware Fusion.app/'):
        driver = 'vmwarefusion'
    else:
        driver = 'virtualbox'

    if args.DOCKER_CLUSTER == 'swarm':
        swarm_args = '--swarm --swarm-master --swarm-discovery token://%s' % args.SWARM_TOKEN
    else:
        swarm_args = ''

    cmd('docker-machine create %(swarm_args)s -d %(driver)s %(name)s || :' % locals())
    start(args)


def start(args):
    """Start the docker-machine"""
    name = args.MACHINE_NAME

    cmd('docker-machine start %s || :' % name)
    cmd('docker-machine scp /usr/local/docker-dev/machine/bootsync.sh %s:/tmp/bootsync.sh' % name)
    cmd('docker-machine ssh %s sudo mv /tmp/bootsync.sh /var/lib/boot2docker/bootsync.sh' % name)
    cmd('docker-machine ssh %s /var/lib/boot2docker/bootsync.sh' % name)

    if args.DOCKER_CLUSTER == 'kubernetes':
        swarm_args = ''
        _start_kubernetes(args)
    elif args.DOCKER_CLUSTER == 'swarm':
        swarm_args = '--swarm'
    else:
        swarm_args = ''

    log.info('*' * 50)
    log.info('Docker machine available at %s.local (ping it)' % name)
    out = cmd('docker-machine env %s %s' % (swarm_args, name), output=True)
    log.info('\n%s', out.strip())
    log.info('*' * 50)


def stop(args):
    """Stops the docker-machine"""
    cmd('docker-machine stop %s' % args.MACHINE_NAME)


def update(args):
    """Updates docker-dev to the latest version"""
    if CWD == '/usr/local/docker-dev':
        cmd('git fetch -q https://github.com/dasein/docker-dev.git %s' % args.GIT_BRANCH)
        cmd('git reset --hard FETCH_HEAD')
    else:
        log.info('docker-dev is not installed in /usr/local (Skipping git update)')

    playbook = os.path.join(CWD, 'ansible/docker.yml')
    cmd('ansible-playbook %s -i 127.0.0.1,' % playbook)


def upgrade(args):
    """Upgrades docker-machine to latest version of boot2docker"""
    cmd('docker-machine upgrade %s' % args.MACHINE_NAME)
    start(args)


def rm(args):
    """Removes the docker-machine"""
    cmd('docker-machine rm %s' % args.MACHINE_NAME)


def ls(args):
    """Lists the docker-machine(s)"""
    cmd('docker-machine ls')


def _start_kubernetes(args):
    """Start kubernetes on docker machine"""
    log.info('Starting Kubernetes dev cluster')

    env = 'eval "$(docker-machine env %s)"' % args.MACHINE_NAME

    cmd('kubectl config set-cluster docker-dev --server=http://localhost:8080')
    cmd('%s && docker-compose -f compose/kubernetes-dev.yml stop' % env)
    cmd('%s && docker-compose -f compose/kubernetes-dev.yml rm -f' % env)
    cmd('%s && docker ps -a -f "name=k8s_" -q | xargs docker rm -f' % env)
    cmd('%s && docker-compose -f compose/kubernetes-dev.yml up -d' % env)
    cmd('pkill -f "ssh.*8080:localhost" || :')
    cmd('docker-machine ssh %s -f -N -L "8080:localhost:8080"' % args.MACHINE_NAME)
    cmd('until $(kubectl --cluster=docker-dev cluster-info &> /dev/null); do sleep 1; done')
    cmd('kubectl --cluster=docker-dev --namespace=kube-system create -f k8s/kube-ui-rc.yaml')
    cmd('kubectl --cluster=docker-dev --namespace=kube-system create -f k8s/kube-ui-svc.yaml')
    log.info('Kube cluster is up')
    log.info('Access using kubectl --cluster=docker-dev')
    cmd('kubectl --cluster=docker-dev cluster-info')


def main():
    """Setup and invoke docker-dev environment"""
    logging.basicConfig(stream=sys.stderr, format='[%(levelname)s] %(message)s')

    env = os.environ.keys()
    os.environ.update({k:v for k,v in DEFAULT_MACHINE_ENV.iteritems() if k not in env})

    bare_commands = [ update, ls ]
    name_commands = [create, start, stop, rm, upgrade]

    subparsers = PARSER.add_subparsers()
    for command in bare_commands + name_commands:
        s = subparsers.add_parser(command.__name__, help=command.__doc__)
        if command in name_commands:
            s.add_argument('MACHINE_NAME', nargs='?', default=os.getenv('MACHINE_NAME'))
        s.set_defaults(func=command)

    args = PARSER.parse_args()

    if args.verbose:
        log.setLevel(logging.DEBUG)
    else:
        log.setLevel(logging.INFO)

    if 'MACHINE_NAME' in args and not args.MACHINE_NAME:
        log.info('MACHINE_NAME not set, using "dev" as machine name')
        args.MACHINE_NAME = 'dev'

    args.func(args)

if __name__ == '__main__':
    main()
